앱에 css를 적용하고 vercel에 배포하는 실습 및 최적화

# **#4.1 CSS Modules**

NextJS에서는 바로 CSS 모듈을 사용할 수 있음.

어떤 설정을 따로 하지 않아도 됨.

- 별도의 설치나 설정이 필요 없음.

**첫 째로 globa css를 생성한다.**

css 모듈은 말 그대로 css를 포함하는 모듈을 생성하는 것.

style을 분리해서 css모듈을 만든다.

전체 웹사이트의 background color나 font를 설정하기 위해 global css를 생성한다.

- styles 폴더 생성
- global.css 생성
- css 작성
  - global.css에는 전역적인 내용만 작성한다.
  - reset.css 같은 내용..
- root layout에서 import
  - import “../styles/global.css”;

css module 작성

- 네비게이션 컴포넌트를 꾸며준다면
- navigation**.module.css** 작성
  - .module.css가 들어가야 한다.
- 위치는 어디든 상관없다.
  - 보통은 네비게이션 컴포넌트 파일 옆에 둔다.
  - 또는 styles 폴더 하위에 작성해도 됨.
- 일반적인 tag를 이용한 selector가 아니라 classname에만 해당되게 작성한다.
- html영역에서도 기존처럼 classname을 작성하지 않음
- import styles from “../styles/navigation.module.css”
  - 이게 javascript 파일인 것처럼 생각해야됨.
  - classname을 보유한 javascript object라고 생각해야됨.
- <nav className={styles.nav}>
- 개발자도구로 class 명을 확인해보면 정의했던 classname이외에 해시값이 추가되어 있음
  - 충돌 우려 없음.
- 반드시 클래스명으로 시작해서 작성해야 되고 이후에는 태그가 들어가도 상관없음.
  - nav a li : 문제있음
  - .nav a li : 문제없음

[정리]

1. 전체 적용되어야 하는 css는 global.css에 작성을 해준다 (module들어가지않음)
2. global.css는 root layout에서 import 해준다.
   1. import “../styles/global.css”;
3. 각 화면별 적용되어야 할 css는 filename.module.css 형식으로 작성한다.
   1. 컴포넌트 파일과 같은 레벨에서 작성
   2. 또는 styles 폴더 하위에 작성
   3. 시작은 항상 className 형식으로 시작해야 한다.
      1. .gnbContainer li a { background-color …. }
4. 적용 할 컴포넌트에서 모듈을 import 하듯이 import 한다.
   1. import styles from “../styles/navigation.module.css”
5. <nav className={styles.className1}> 형식으로 적용한다.

# **#4.2 Movie Styles**

- home group > homepage 이동
- div 생성 하고 movie img 작성
- Link 작성
  - movie 상세 화면 이동 기능
- ㅡmovie component 생성
  - 방금 작성한 내용을 Movie 컴포넌트에 생성
- css module 작성
- home page 적용

Link영역만 누를수 있는 문제가 있음.

router hook을 이용해서 다른 화면을 이동하게끔 재작성 필요

import 할 때 next/navigation을 가져와야 함.

```jsx
const onClick = () ⇒ {
	router.push(".....")
}
```

또한 onClick과 useRouter hook을 사용하므로 client Component가 되어야함

⇒ “use client” 작성

[정리]

1. Link외의 영역 클릭시 화면 이동하기
   1. useRouter Hook 사용
      1. import { useRouter } from "next/navigation";
      2. router.push(`/movies/${id}`);
   2. “use client” 작성 필요
      1. useRouter Hook과 onClick 이벤트는 클라이언트에서 일어나는 이벤트
2. styles 폴더는 app 내부가 아니라 app 폴더와 같은 레벨에 작성하는게 맞는듯..

# **#4.4 Dynamic Metadata**

현재 페이지는 metadata를 가지고 있음.

하지만 상세 페이지에서는 메타 데이터를 갖고 있지 않음.

- 동적 페이지이기 때문에

필요에 따라 metadata를 변경할 수 있음.

두가지 방법

- 모든걸 하나의 페이지로 합치는 방법.
- 다른 방법은 페이지를 분리하는 방법

동적이지 않은 페이지의 경우 하나의 메타 데이터만 가지면 됨.

movie 상세화면 같은 경우 타이틀 제목이 API를 통해 전달됨.

하나의 함수를 만들고 그 함수를 export해줌.

async 함수로 만들고 generateMetadata() fetching을 할 수 있게 해주는 함수

영화의 제목을 반환 타이틀 변경됨

컴포넌트는 id를 통해 어떤 데이터를 받아오는지 알수 있음.

generateMeta 데이터에도 정보 전달 param으로

화면을 구성하게 하기 위한 API 호출 함수를 generateMetadata에서도 한번 호출을 해서 정보를 가져와준다.

⇒ 굳이 두번?

⇒⇒ 최신버전 next가 아니라면 좋지 않은 방법이겠지만 , 최신버전에서는 cache를 지원

⇒⇒ 두번째 fetch때는 캐시 응답을 받게 된다.

[정리]

기존 메타데이터는 정적 데이터에 대해서만 메타데이터를 설정하였다.

영화 상세 화면처럼 동적 라우트를 이용하는 경우에는 해당 화면에 표출할 데이터가 동적으로 변경될 수 있다.

이를 해결하기 위해 동적 메타데이터를 적용한다.

- 설정방법
  1. export, async 함수로 **generateMetadata** 함수 생성
     1. nextjs에서 해당 함수를 찾기위해 함수명이 중요하다.
  2. 함수 내부에서 return 값으로 메타데이터와 동일한 형식 반환

     ```jsx
     export const generateMetadata = async (props: IProps) => {
       const params = await props.params;
       const movie = await getMovie(params.id);

       return {
         title: movie.title,
       };
     };
     ```

  3. 해당 함수에서 한번 더 API를 호출하지만 기존 API가 캐싱되기 때문에 문제가 없다.
- 궁금증
  - 만약 캐시되던 데이터가 없다면 진입속도에 문제를 주지 않을까?
    - API응답이 온 이후에 진입 가능?
  - 또한 캐시되어있다 하더라도 첫번째 응답이 오기전에는 어차피 화면을 진입하지 못하는게 아닌가?

# **#4.5 Deployment**

배포를 하려면 git에 push가 되어있는지 확인이 필요하다.

package.json에 build 커맨드 및 start 커맨드 추가 필요

- 직접 호출하지는 않음
- vercel이 호출

1. vercel로 이동
2. Add New Project
3. 저장 레포 선택
4. 프로젝트 정의
   1. package install..
   2. build command ..
   3. etc …
5. deploy 클릭

page.tsx에서는 아무거나 export할수없음

API_URL을 사용될수 없다?

- constants.ts 같은 곳 새로 정의

링크에 prefetch추가

- 무비 컴포넌트에서 링크컴포넌트에 prefetch 추가
- 이유 : 이전에 안들어갔던 상세화면을 들어가보면 비디오를 불러오는데 시간이 걸림
- API응답속도가 빠르지만 로딩 상태가 표출되는걸 볼수있음.
- 사용자가 클릭하기 전부터 fetch를 하게 됨.
- Link가 화면에 보여지기 시작하면 movie 페이지를 자동으로 fetch함
- 모든걸 prefetch하면 DB가 죽을수도 있으니 주의 필요

[정리]

1. prefetch
   1. 첫 진입하는 상세 페이지의 경우 정보를 불러오는데 시간이 걸림
   2. 아무리 API가 빠르더라도 로딩 상태에 진입이 됨.
   3. 스크롤시 사용자가 클릭하기 전에 미리 fetch를 할 수 있도록 prefetch 속성을 Link 컴포넌트에 추가
   4. 모든 Link에 prefetch시 성능이나 DB문제가 생길수 있으니 주의
2. Vercel 배포
   1. vercel 이동 및 로그인
   2. Add New Proejct → 저장 레포 선택
   3. 프로젝트 정의 (커맨드 설정)
      1. install, build, start
   4. deploy
   5. 고려사항
      1. 레포 경로에 공백이 들어있으면 배포 실패됨.
