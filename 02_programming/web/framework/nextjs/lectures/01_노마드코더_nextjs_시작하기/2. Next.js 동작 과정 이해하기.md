# **#2.1 Defining Routes**

새로운 페이지 만드는 방법을 학습한다.

기존 React에서는 대부분 react-router를 사용하며 url을 지정하고 접근시 특정 Component를 연결하는 형식이었다.

Next.js는 직접 URL을 작성할 필요 없이 파일 시스템을 통해 URL을 표현한다.

app 폴더내의 page파일은 유저가 root에서 보게될 페이지로서 root segment라고 부른다.

만약 /about-us 경로의 페이지를 만들고 싶다면 /app/about-us라는 폴더를 만든다.

폴더를 만들고 접근해보면 404가 표출되는데 이것은 Nextjs가 접근할 UI가 없어서임.

처음 만들었던 컴포넌트(app 바로 하위의 page.tsx)처럼 페이지를 /about-us 폴더 하위에 작성하면

/about-us 페이지로 접근시 작성한 페이지가 표출된다.

같은 원리로 중첩 라우트를 표현하기 위해 중첩 폴더 형태를 구성할 수 있다.

app > depth1 > depth2 > depth3 > page.tsx

→ http://localhost:3000/depth1/depth2/depth3 형태로 접근 가능

→ 만약 depth1, depth2에 page파일이 없다면 해당 경로는 접근 불가

# **#2.2 Not Found Routes**

page 파일명 이외에도 not found 페이지를 표현하기 위해서 not found 파일을 작성 할 수 있다.

app/not-found 파일 생성을 생성하게 되면 실제 없는 경로를 접근 할 때 미리 정의한 페이지를 표출 할 수 있다.

## 네비게이션 만들기

모든 페이지에서 사용 할 Navigate Component를 만들기 위하여

app 폴더의 동일한 레벨의 경로에 components 폴더 생성 > navigation 파일을 추가 한다.

브라우저 네비게이션(a tag)가 아닌 프레임워크 네비게이션을 사용하여 구현한다 (Link tag)

```jsx
"use client";
import Link from "next/link";
import { usePathname } from "next/navigation";

export default function Gnb() {
  const pathname = usePathname();
  console.log("ytw pathname", pathname);
  return (
    <div>
      <ul>
        <li>
          <Link href="/">루트 경로 화면 {pathname === "/" ? "🤏" : ""} </Link>
        </li>
        <li>
          <Link href="/main">
            홈 메인 화면 {pathname === "/main" ? "🤏" : ""}
          </Link>
        </li>
        <li>
          <Link href="/main/mode-edit">
            모드 편집 {pathname === "/main/mode-edit" ? "🤏" : ""}
          </Link>
        </li>
      </ul>
    </div>
  );
}
```

컴포넌트를 생성 후 각 페이지별로 컴포넌트를 추가한다

⇒ 좋은 방법은 아니고 추후 개선 예정

usePathname()을 이용하여 현재 위치하고 있는 path를 추출

⇒⇒ usePathname은 client component에서만 작동한다고 오류가 표출 됨.

⇒ 파일 최상단에 “use client” 작성

# **#2.3 SSR vs CSR**

usePathname은 Client Component에서만 작동하게 된다.

기존 react는 클라이언트에서만 렌더링을 하게 된다.

- 페이지의 실제 html 코드는 비어있는채로 Client에 전달
- 이후 js를 전달 받고, 브라우저의 JS 엔진에 의하여 HTML 내부 내용물이 채워짐
- 화면에 아무것도 없는채로 깜빡이는 순간 : js가 모두 다운되고 태그가 추가 됨
  - js를 비활성화 시키면 앱을 실행시킬수가 없음.

이런 동작 방식으로 인하여 SEO가 원활이 되지 않는 문제가 있다.

- html 파일 자체가 비어있기 때문에 검색 엔진에서 수집할 데이터가 없음.

이에 반해 SSR의 경우 html 파일 자체에 내용이 기본적인 내용이 적용되어 표출한다.

UI가 이미 빌드되어 전달 되기 때문에 JS가 필요없는 UI에 대해서는 바로 확인이 가능하다.

“use clinet”가 있든 없든 상관 없이 컴포넌트와 페이지에 대해 서버측에서 먼저 html로 변환하는 작업을 한다.

# **#2.4 Hydration**

사용자가 최초 HTML을 본 이후에 일어나는 과정에 대한 학습

브라우저 javascript를 disable 상태로 네비게이션의 화면을 이동할 경우 페이지가 새로고침 된다.

하지만 브라우저 js를 enable 상태로 이동한다면 새로 고침 되지 않는다.

이유는 react가 하이드레이션 되기 때문인데,

JS가 적용되지 않게 될 경우 a태그의 동작을 하지만 Link 컴포넌트의 동작을 수행하게 된다.

⇒ html상으로는 a태그 그대로 존재하지만, 이것은 javascript로 제어됨.

사용자 웹페이지 접속 → HTML 전달(기능없음) → 사용자 : 기능없는 HTML 확인→ JS전달(기능생성)

# **#2.5 'use client'**

하이드레이션 과정은 필요한 컴포넌트에 대해서만 발생하며 모든 컴포넌트에서 발생하지는 않는다.

해당 과정을 거치지 않는다고 해서 클라이언트에서 렌더링 하는 것은 아니며,

render 자체는 서버사이드에서 모두 발생하게 된다.

이 때 클라이언트에서 하이드레이션 할 컴포넌트에 “use client”를 작성하면 되며,

작성할지 안할지 고민할 필요 없이 필요한 컴포넌트에 적용되어 있지 않을 경우 Next에서 에러를 표출한다.

- framework : 현재 컴포넌트는 interactive하기 때문에 use client를 작성해야 한다.

선언시 : 클라이언트 컴포넌트

미선언 : 서버 컴포넌트

Server Component에서 DB 연동 , API Fetch등을 할 경우 해당 코드들이 client로 전달되지 않기 때문에 보안에 신경을 덜 쓸 수 있다.

# **#2.7 Layouts**

레이아웃 시스템을 배우는 이유는 빌드시 재사용하는 요소들이 있기 때문.

네비게이션 같은 컴포넌트를 페이지에서 사용해야 할 때

페이지마다 gnb 컴포넌트를 import하여 작성해야 하는 불편함이 있다.

layout을 모든 화면에 일괄적으로 적용하려면 아래와 같이 작성한다.

```jsx
import Gnb from "../components/gnb";

export const metadata = {
  title: "Next.js",
  description: "Generated by Next.js",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode,
}) {
  return (
    <html lang="en">
      <body>
        <Gnb />
        {children}
      </body>
    </html>
  );
}
```

layout은 한개 뿐만 아니라 새로운 형태의 레이아웃을 만들 수 있다.

about-us 페이지의 특별한 레이아웃이 필요하다면 해당 폴더에 특별한 layout.tsx 파일을 만들어준다

abount-us 하위로 여러개의 중첩 라우팅 페이지를 생성한다면

해당 페이지도 마찬가지로 about—us의 layout을 적용 받는다.

주의 : 레이아웃끼리 상쇄되는게 아닌 중첩적으로 적용을 받는다.

(기존 루트 레이아웃내에 about-us의 레이아웃이 생기는 개념)

# **#2.8 Metadata**

route gropups & metadata object에 대해 알아본다 .

routes들을 그룹화해서 logical groups로 만들어 복잡한 일을 처리하거나

루트 레이아웃을 사용하지 않고 여러 레이아웃을 선택하거나 선택 해제 , 중첩 레이아웃을 원하지 않는경우에도 사용한다.

루트 경로에 layout, not found, page 세개가 있는데

layout과 not found는 모든 페이지에서 사용이 필요하다 .

홈에만 특정된것은 page.tsx

새폴더를 만들고 괄호로 묶어준다. app/(home)

page를 드래그해서 (home)으로 옮긴다.

라우트 그룹은 이런식으로 폴더 이름을 괄호로 묶어준다.

괄호로 묶을경우 url을 생성하지 않는다

about-us는 접근 경로가 생성되지만 (home)은 생성되지 않는다.

메타데이터

꼭 내보내야하는 object이며 메타데이터라고 한다.

title : 브라우저 탭에 제목 표시 : 페이지의 head > title

description도 있음.

→ 이전버전에 비해 훨씬 쉬워졌음

홈에서만 보여줄 경우 page.tsx로 와서 메타데이터 작성

레이아웃 중첩처럼 메타데이터도 중첩되지만 메타데이터는 정확히 ‘병합’ 되는 것임

디스크립션은 공통으로 넣어주고 타이틀만 따로 넣어줄수도 잇음 .

페이지 또는 레이아웃만 메타데이터를 내보낼 수 있음.

클라이언트 컴포넌트에서는 안되고 서버컴포넌트에서만 있을 수 있음.

메타데이터의 title에서 똑같은 부분이 계속 있다면 ?

→ 메타데이터도 템플릿을 만들 수 있음.

```jsx
export const medatada = {
  title: {
    template: "%s | Next Movies",
    default: "Loading...",
  },
};
```

page에서 설정하지 않은 화면으로 이동해보면 default가 표출됨

만약 동적으로 title이 변경된다고 하더라도 사용할 수 있는 기능이 제공됨.

# **#2.9 Dynamic Routes**

다이나믹 라우트는 이전에 만들었던 about-us같은 곳이 아니라(이건 정적)

/movies/3445646 등 뒤에 나오는 url이 동적으로 변경될수 있는 경우

영화 목록이 표시되고 상세 페이지로 진입시 /movies/:id 와 같이 이동

대괄호를 이용해서 만든다 (movies/[id])

[id] 폴더 하위에 page.tsx 파일 생성

{origin}/movies/12312 접근시 해당 화면 표출

page.tsx파일에서 props 확인

params는 동적라우팅에서 :id영역에 넣은 값

searchParams는 query string 형태로 넣은 값을 확인 가능

강의에서는 props를 바로 확인할 수 있지만

테스트해보니 promise 형태로 오는 것을 확인. 14or15버전에서 뭔가 변경 된 듯함.

아래와 같은 방식으로 코드 수정

```jsx
export default async function MovieDetail(props) {
  const params = await props.params;
  return <h1>movie / {params.id}</h1>;
}
```

Nextjs에서 알아서 인식을 함. Hook같은게 필요가 없음.
